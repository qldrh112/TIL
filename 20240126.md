# 20240126
## 제목
### 오전
### 오후





### 알고리즘
이번 문제는 10개의 수를 받아 그 안에서 최댓값과 최솟값을 제외한 값의 평균을 구하는 문제였다.  
최솟값과 최댓값을 날리는 것과 값의 평균을 구하는 것 2가지를 수행해야 한다.  
먼저, 최소,최대값을 날리는 방법은 2가지 정도 생각이 났는데  
1. sort()함수로 리스트를 정렬해서 pop으로 날리는 방법
2. min()과 max()함수로 값을 각각 출력해서 remove로 날리는 방법

알고리즘 문제 풀이에서 중요하는 것은 메모리 사용과 실행 시간인데 어떤 방법이 더 효율적인지는 아직까지는 잘 모르겠다.  
각설하고, 평균 값을 구하는 방법은 한 가지 생각이 들었다.
1. sum()/len()으로 구하는 것이 가장 편할 것이라고 생각을 하였다.

그래서 최초 구상한 코드는 
``` python

# 초안
T = int(input())
for t in range(T):
    input_lst = input().split()

    # 최대, 최소값 삭제
    input_lst.remove(max(input_lst))
    input_lst.remove(min(input_lst))
    
    # 평균 출력
    print(f'#{t+1} {sum(input_lst)/len(input_lst)})

    # 문제는 여기서 소수점이 나오면 어떻게 하지??
```

가장 큰 문제는 문제 조건에 따르면 출력 결과는 소수점 첫째 자리에서 반올림해야 하는 것이었다. `int`는 실수를 넣었을 때, 무조건 버림을 하기에 적절치 않다. 마찬가지로 math 모듈에 있는 `ceil`과 `floor` 또한 올림과 내림만 수행하므로 적절치 않다는 생각이 들었다. 그러다가 검색을 통해 round()함수를 알았고, 그것을 적용하기로 했다. 올해 파이썬 예습을 진행할 때, 봤던 것 같은데 기억이 나지 않아 아쉽다.

한 번에 통과할 것이라고 하였다.
`TypeError: unsupported operand type(s) for +: 'int' and 'str'` 발생
적당하지 않은 피연산자 유형이라는 오류가 발생하였다. 처음에는 평균을 출력하는 부분에서 오류가 발생한 줄 알았으나 sum과 len에는 무리가 없었다. 그러다가 input_lst를 출력해 보았는데 리스트 안에 문자열로 들어있었던 것이었다. 이 얼마나 놀라운 일입니까. 문자열 형태로 한 칸 씩 띄어져 있는 것을 받을 때는 `list(map(int, )` 콤보를 사용해야 한다는 것을 잊어서는 안 될 것이다.

```python

# 최종 제출
T = int(input())
for t in range(T):
    input_lst = list(map(int, input().split()))
    # [3, 17, 1, 39, 8, 41, 2, 32, 99, 2]

    input_lst.remove(max(input_lst))
    input_lst.remove(min(input_lst))

    # 평균을 구하고, 첫째 자리에서 반올림한 뒤, 정수로 변경하여 출력

    print(f'#{t+1} {int(round(sum(input_lst)/len(input_lst), 0))}')
```
다행히도 무사히 통과하였다. 이렇게 간단한 문제는 어제와 같이 한 번에 뽑아버렸어야 하는데 아쉬운 부분이 있었다. 그리고 다른 사람들과 비교했을 때, 메모리와 실행 시간이 좋은 수준이 아니었다. 내가 지금 생각했을 때, 가장 효율적으로 코드를 짠 것이라고 생각했는데 차차 알고리듬 수업을 들으면서 시간 단축 기법 등을 배워야 할 듯 하다.
















### 자습
#### tmp2.py
어제 받은 2개 중 하나는 난이도가 확 올라 해석하는 데 시간이 걸려 오늘 수행하였다. 역시 개발은 하면 할수록 표현할 수 있는 격이 달라지는 것을 느낀다. 우선 코드부터 살펴보자.
``` python
from tqdm import tqdm
import random

def monster(hp, gold):
    hp -= 4
    gold += 1
    
    return hp, gold

def merchant(hp, gold, level):
    if gold >= 2:
        hp += 5
        gold -= 2
    
    if hp > 10+level:
        hp = 10+level
            
    return hp, gold

def digging(gold):
    gold += 2

    return gold

if __name__ == "__main__":
    list_a = []
    count = 0
    for i in range(1):
        karma = 1
        step = 0
        while step < 50:        
            hp = 10
            level = 0
            gold = 0
            killcount = 0
            print(f'이것은 {karma}번째 삶이다.')
            print(f'50걸음을 걸으면 해방될 수 있다.')
            while True:
                step += 1
                a = random.choice([1, 1,1,1,1,1,1,2,2,3]) #1 = 괴물 / 2= 포션 / 3 = 득템  // 간단한 밸패 가능

                if a == 1:
                    print('괴물이다!')
                    hp, gold = monster(hp, gold)
                    if hp > 0:
                        print(f'용사는 괴물을 죽였다! 지금 체력은 {hp}이다. \n가진 돈은 {gold}gold이다.')
                        killcount += 1
                        if killcount % 4 == 0 and killcount != 0:                    
                            print('용사는 강해진 기분이다.... 최대체력이 1 증가하였다.')
                            level += 1
                    else:
                        print(f'체력이 없다. 죽을 것 같다....')                    
                elif a == 2:
                    if hp < 10:
                        hp, gold = merchant(hp, gold, level)
                        print(f'용사는 빨간포션을 샀다. 지금 체력은 {hp}이다.\n가진 돈은 {gold}gold이다.')
                else:
                    gold = digging(gold)
                    print(f'용사는 돈을을 주웠다. \n가진 돈은 {gold}gold이다.')
                        
                
                
                if hp < 1:
                    karma += 1
                    print('='*50)
                    print(f'용사는 {step}걸음 만에 죽었다. 그의 레벨{level}이었다.\n{killcount}마리의 괴물을 죽였고, 가진 돈은 {gold}gold였다.')
                    print('='*50)
                    step = 0
                    hp = 10
                    gold = 0
                    killcount = 0
                    level = 0
                
                if step == 50:
                    break
        print('='*50)
        print(f'용사는 해방되었다.\n{karma}번째 환생의 결과다.... \n그의 레벨{level}이었다.\n{killcount}마리의 괴물을 죽였고, 가진 돈은 {gold}gold였다.')
        print('='*50)
        
        list_a.append([karma, level])
   
    for i, (hero, level) in enumerate(list_a):
        
        if hero == 1:
            print(f'{i}번째 용사는 환생없이 탈출하였다. 그는 운좋은 새끼이다. 도달한 레벨은 {level}이다.')
            count += 1
    
    print(f'운좋은 새끼는 {count}명이었다.')
```

처음부터 신기한 모듈로 인해 당황하였다. `tqdm`이라는 신기한 모듈인데 [pypi](https://pypi.org/project/tqdm/)에서 한 번 살펴보았다. gif로 기깔나게 설명해주니 설명서를 영어로 읽기 싫었던 나에게 도움이 되었다. for문 등의 반복문의 진행 정도를 시각화하여 보여주는 모듈인 것 같았다. 모듈을 불러주고 range앞에 `tqdm`을 집어넣으면 자동으로 동작하는 것 같다. `range()`안에 옵션을 달아서 진행할 수도 있는 것 같다. 우선 여기까지 하고 몬스터는 호출되면 체력 4를 잃고 골드 1을 주는 것 같다. 상인은 체력과 골드가 많으면 이익을 주는 듯 하다.