# 20240529
## 
### 오전
#### 서버관리
보통은 윈도우만 사용해봤을 것임  

##### 서버관리와 리눅스
서버: 하나의 컴퓨터  <-> 클라이언트  
리눅스: 운영체체(서버를 움직이는 녀석)  

서버컴퓨터는 대부분 리눅스를 사용하기 때문에 잘 알고 있어야 한다.  

리눅스를 사용하는 이유  
1. 오픈소스로 공개되어 있고, 무료다. 윈도우는 옵션이다.  
2. 안정성  
3. 보안과 안정성. 윈도우도 안 좋다 하지만 많이 좋아졌다.  

rinux 리너스 토발즈 라는 작자가 기획했다.  
git도 리너스 토발즈라는 작자가 만들었다.  

richard stallman이라는 사람이 copy left를 주창함  
software의 상용화를 위하여  

위의 두 사람이 힘을 합쳐 GNU 프로젝트를 기획  
GNU: GNU in not Unix  
프로젝트의 간판 운영체제가 필요했는데  

리눅스의 종류는 여러 개가 존재한다.  
데비안 계열(우분투 등), 레드햇 계열  

운영체제를 지금 한 번에 바꿔버리면 내가 지금 잘 사용하고 있는 프로그램을 사용하지 못 할 수도 있다.  

##### 서버관리와 네트워크
네트워크 없이 서버관리를 한다?  
말도 안 되는 이야기  

- NAT: Network Address Translation, 네트워크 주소 변환  
가상머신이 몇 개이든 ip 주소는 다 같다.  

내부 네트워크에서 외부 네트워크로 단방향 연결, 외부에서 내부로 못 들어감  
내부에서는 naver.com 접속이 가능한데 외부에서 내부를 못 간다.  
그래서 설정을 해야 한다.  
문제는 외부에서 볼 때는 가상 머신을 인지할 수도 없고 IP를 알 수가 없다.  
포트포워딩을 통해 host가 내부로 갈 수 있는 이정표를 생성  

포트 번호를 보고 우리 컴퓨터 안의 어떤 프로그램과 이야기를 할 것인가 결정한다.  
vue3는 5713, django는 8000  

호스트는 내 컴퓨터이고, 게스트는 가상 머신이다.  

- 어댑터의 브리지
컴퓨터가 router에 주소를 받고 사용하고 있는데 어댑터의 브리지를 사용하면  
컴퓨터의 ip 주소에 이어서 사용할 수 있다.  
192.168.0.1 ~ 3  
하지만, 가상 머신 간 독립적인 네트워크를 가질 수 없다.  

- NAT Network: NAT와 비슷하지만, 내부 네트워크의 게스트 간 통신 가능   

##### Public & Private Network
네이버에서 알려주는 주소는 인터넷에서 알고 있는 내 ip 주소라고 한다.  
공유기에 연결된 컴퓨터가 인식하는 ip 주소는 다를 수도 있다.  

##### 프록시
프록시: 클라이언트와 서버 사이에서 중개자 역할을 하며 대리로 통신하는 것  
프록시 서버: 중계 역할을 하는 서버(컴퓨터)  
포워드 프록시, 리버스 프록시: 프록시 서버 위치에 따라서 다르다.  

클라이언트가 요청을 하면 프록시 서버에 들른다.  
내 IP 주소는 프록시 서버를 거치며 바꾸게 설정할 수 있다.  
이것의 장점은 서버가 나를 누군지 모르게 할 수 있다.  

포워드 프록시: 클라이언트 쪽에 있다, 서버와의 통신 중개, ip 우회, 클라이언트의 익명성 보안, 컨텐츠 제한(회사 컴퓨터에서 sns 제한 등 )  
리버스 프록시: 서버 측에 있다. 서버 대신 클라이언트와 통신 중개, 로드밸런싱(부하 분산, dos 공격 등 대신 맞아버리기), 원본 서버의 ip를 숨김, 캐싱  


##### Linux shell & CLI command
CLI: 커맨드 라인 인터페이스  

shell: 운영체제와 사용자를 이어주는 시스템 프로그램, 사용자의 명령어를 해석하는 인터프리터  
명령어는 sudo, ls, rm, mv 등 익숙한 것도 있고, 다양하다.  

서버 컴퓨터의 모니터는 달려 있지 않는 경우가 많다.  
왜 why? 모니터가 잡아먹는 자원이 생각보다 크다.  
그래서 명령어를 통해 진행을 한다.  

w: 쓰기, r: 읽기, x: 실행  

`ls -al | grep '.bash*'`: grep으로 문자열 검색 와일드카드와 파이프라인을 활용한 검색  

sudo: 루트 권한으로 실행  
apt / apt-get: Debian 기반 리눅스 패키지 관리자 도구  
clear: 우리가 아는 터미널 비우기  


##### ssh와 원격 서버 관리
ssh: secure shell의 줄임말  
서울의 본사와 부산의 서버 컴퓨터를 연결하는 것  

통신 규약: 데이터의 형식, 순서 등을 결정  

ssh 프로토콜: 다른 컴퓨터에 안전하게 데이터를 전송하는 방법, 암호화를 사용하여 장치 간 연결을 인증, 데이터 암호화  
-> 원격으로 서버를 관리하는 데 아주 유용함  

중간자 공격: 네트워크 상에서 데이터를 주고받는 두 시스템 사이에 칩입하여 중간자 역할을 함으로써 데이터를 변조하거나 가로챔  
이전에 ssh를 통해 127.0.0.1 주소에 접근한 적이 있고, 그 주소에 연결된 서버나 컴퓨터가 변경되었기 때문에 경고  
-> 서버가 변경된 경우, 이전의 인증 정보를 참고할 수 없음  

##### AWS
.pem 보다 .ppk를 보안적으로 좋아서 인기가 많다.  
ppk는putty라는 놈과 같이 사용한다.  

##### 배포 실습
서버에 url이 전달되면 nginx가 백과 프론트 각각에 url을 나눠서 뿌린다.  
중개자 역할은 프록시가 한다.  
실습에서는 서버 쪽에 있으니 리버스 프록시라고 봐도 된다.  

``` js
t(e,t,n=!1,r=!1){e=e.__v_raw;const s=D(e),o=D(t);n||(We(t,o)&&se(s,"get",t),se(s,"get",o));const{has:i}=rn(s),l=r?or:n?ur:wt;if(i.call(s,t))return l(e.get(t));if(i.call(s,o))return l(e.get(o));e!==s&&e.get(t)}function Bt(e,t=!1){const n=this.__v_raw,r=D(n),s=D(e);return t||(We(e,s)&&se(r,"has",e),se(r,"has",s)),e===s?n.has(e):n.has(e)||n.has(s)}function Lt(e,t=!1){return e=e.__v_raw,!t&&se(D(e),"iterate",qe),Reflect.get(e,"size",e)}function vr(e){e=D(e);const t=D(this);return rn(t).has.call(t,e)||(t.add(e),Te(t,"add",e,e)),this}function Mr(e,t){t=D(t);const n=D(this),{has:r,get:s}=rn(n);let o=r.call(n,e);o||(e=D(e),o=r.call(n,e));const i=s.call(n,e);return n.set(e,t),o?We(t,i)&&Te(n,"set",e,t):Te(n,"add",e,t),this}function Br(e){const t=D(this),{has:n,get:r}=rn(t);let s=n.call(t,e);s||(e=D(e),s=n.call(t,e)),r&&r.call(t,e);const o=t.delete(e);return s&&Te(t,"delete",e,void 0),o}function Lr(){const e=D(this),t=e.size
```
실행만 되면 되기에 극한의 압축이 되어 있다.  

포트번호에 따라서 연결되는 프로그램이 다르다.  

##### 서버관리와 리눅스
##### 서버관리와 리눅스
