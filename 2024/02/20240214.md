# 20240214
## 이걸 밤에 작성할 줄이야
### 오전
#### 스택2
##### [보론] 부분집합, 순열
부분집합을 만드는 방법
1. for문 
2. bit 연산을 활용한 

``` python
# 부분집합의 합 구하기
# 필요한 부분 털기

def f(i, k, s, t):
    global cnt
    cnt += 1
    # 모든 원소가 결정되었을 때
    if s == k:
        # 부분집합 원소의 합
        for j in range(k):
            # a[j]가 포함된 경우
            if bit[j]:
                print(a[j], end=' ')
        print()

    # 끝까지 도달했음에도 다 찾지 못한 경우
    elif i == k:
        return
    # 고려한 원소의 합이 t보다 큰 경우
    elif s > t:
        return

    else:
        bit[i] = 1
        f(i+1, k, s+a[i], t)
        bit[i] = 0
        f(i+1, k, s, t)
        # for j in range(1, -1, -1):
        #     bit[i] = j
        #     f(i+1, k)

n = 10
a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
# bit[idx] = a[idx]의 포함 여부
bit = [0] * n
cnt = 0
f(0, n, 0, 10)
print(f'cnt: {cnt}')
```
### 오후
완전검색은 시간적으로 가장 오래 걸리지만, 부분적으로 사용하면 야미다.  
중간에 합을 구하는 것처럼 가지치기가 가능하면 재귀가 쓸모가 있을 수도 있다.

#### 분할정복
분할 정복 문제는 오후에 문제 풀이로 대체한 것 같다.  
1~2시간 정도 풀다가 안 풀려서 때려쳤는데 문제는 잘 이해했으나 접근이 아쉬워서 도달하지 못 했던 것 같다.  
다행인 것은 이제는 A형을 위한 과정이라 너무 조급하지 않아도 된다는 것이다.  
다른 말로 하면 전공 반이었다면 기본이 이것이라는 것인데 오묘한 감정이 든다.

### 자습
요즘 평일에 오후나 자습 분량이 미미한 모습을 확인할 수 있는데, 이는 문제 풀이를 하다가 잘 풀리지 않아 너무 몰두하는 나머지 .md 파일에 중간 과정 코드와 어려웠던 점을 넣어놓지 않기 때문이다. 게다가 쉬는 시간도 잘 지키고 있지 않다. 확실히 가장 좋은 방법은 제 시간 안에 문제를 쏙쏙 풀어내는 것인데 내게 주어진 시간은 생각보다 많지 않다. 그렇게 효율적으로 공부를 해야 할 필요가 있을 것 같다.  
선생님께서 말씀하시는대로 딥러닝보다는 오늘처럼 몇 시간 해보다가 안 되는 건 털고, 해설 듣고, 동료들의 코드를 보고 영감을 얻어 다시 짜는 방식으로 하면서 시간 관리를 해야 할 것 같다. 그래야 오늘처럼 밤에 .md파일 작성해서 다음 날의 체력을 빌려 쓰는 일은 없게 해야겠다.

