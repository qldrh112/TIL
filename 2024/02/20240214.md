# 20240214
## 제목
### 오전
##### [보론] 부분집합, 순열
부분집합을 만드는 방법
1. for문 
2. bit 연산을 활용한 


``` python
# 부분집합의 합 구하기
# 필요한 부분 털기

def f(i, k, s, t):
    global cnt
    cnt += 1
    # 모든 원소가 결정되었을 때
    if s == k:
        # 부분집합 원소의 합
        for j in range(k):
            # a[j]가 포함된 경우
            if bit[j]:
                print(a[j], end=' ')
        print()

    # 끝까지 도달했음에도 다 찾지 못한 경우
    elif i == k:
        return
    # 고려한 원소의 합이 t보다 큰 경우
    elif s > t:
        return

    else:
        bit[i] = 1
        f(i+1, k, s+a[i], t)
        bit[i] = 0
        f(i+1, k, s, t)
        # for j in range(1, -1, -1):
        #     bit[i] = j
        #     f(i+1, k)

n = 10
a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
# bit[idx] = a[idx]의 포함 여부
bit = [0] * n
cnt = 0
f(0, n, 0, 10)
print(f'cnt: {cnt}')
```

완전검색은 시간적으로 가장 오래 걸리지만, 부분적으로 사용하면 야미다.  
중간에 합을 구하는 것처럼 가지치기가 가능하면 재귀가 쓸모가 있을 수도 있다.



























#### 스택2
##### 분할정복
### 오후
### 알고리즘
``` python
# 1차 제출
def find_most_number(scores):
    """
    params scores: 학생들의 성적 리스트(list)
    return: 최빈수
    """
    max_v = 0
    for num in range(0, 100+1):
        if max_v <= scores.count(num):
            print(max_v, num)
            max_v = num
    
    return max_v

T = int(input())
for t in range(T):
    tc = int(input())
    input_nums = list(map(int, input().split()))
    # 출력합니다.
    print(f'#{tc} {find_most_number(input_nums)}')
```

``` python
# 최종제출
# 실행시간 215ms
# 메모리 62,008kb
def find_most_number(scores):
    """
    params scores: 학생들의 성적 리스트(list)
    return: 최빈수
    most_num: 최빈수
    max_v: 최빈수의 등장빈도
    """
    most_num = -1
    max_v = -1

    for num in range(0, 100+1):
        if max_v <= scores.count(num):
            most_num, max_v = num, scores.count(num)
    
    return most_num

T = int(input())
for t in range(T):
    tc = int(input())
    input_nums = list(map(int, input().split()))
    # 출력합니다.
    print(f'#{tc} {find_most_number(input_nums)}')
```

``` python
# 수정 1
# 실행시간 226ms
# 메모리 62,004kb
most_num = -1
max_v = -1
total = 1000

for num in range(0, 100+1):
    if max_v <= scores.count(num):
        total -= scores.count(num)
        if total < max_v:
            return most_num
        most_num, max_v = num, scores.count(num)

return most_num
```


### 자습

