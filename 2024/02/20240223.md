# 20240223
## 제목
### 오전
#### start2
##### 비트 연산
bit: 0과 1로 표현하는 정보의 단위  
byte: 8bit를 묶은 단위  

1001011011011100 은 16bit 이며 2byte이다.  

오늘은 비트연산을 활용한 코딩 방법을 익힐 것  
`>>` `<<` 등이 있는 것은 알고 있다.  
and, or은 논리 연산자라고 한다.  
비트 연산자는 `&`와 `|`를 활용한다.  

``` python
# 정수를 비트 연산자로
>>> print(7 | 5)
7
>>> print(7 & 5)
5
```

7 = 0b111  
5 = 0b101  
& = 0b101  

7 = 0b111  
5 = 0b101  
| = 0b111  

``` python
# 10진수를 2진수와 16진수로
>>> print(bin(10))
0b1010
>>> print(hex(10))
0xa
# 2진수와 16진수를 10진수로
>>> print(int('1001', 2))
9
>>> print(int('AA', 16))
170
```

xor: or의 결과를 반대로 출력한다고 보면 된다.  
or를 하고 뒤집어도 된다는 것이죠  
어떤 값이던 임의의 수로 2회 xor을 하면 원래 수로 돌아온다.  

암호 개념에 사용할 수 있을 것이다.  
``` python
# xor의 특이함을 이용한 암호 인코딩 디코딩
def encoding(key):
    return key ^ 9999


def decoding(key):
    return key ^ 9999


input_key = int(input())
print(f'E {encoding(input_key)}')
print(f'D {decoding(encoding(input_key))}')
```

진수 `<<` 숫자: 왼쪽으로 비트를 밀어낸다.  
진수 `>>` 숫자: 오른쪽으로 비트를 밀어낸다.  

``` python
# 비트 연산을 이용한 출력 연습
def left_shift(n):
    for i in range(n):
        print(bin(0b1 << i), 0b1 << i)


n = int(input())
left_shift(n)
```
1 << n  
출력 결과는 2의 제곱수다. 몽키  
임베비드 분야에서 계산을 빠르게 하기 위해 사용한다.  

`i & (1<<n)`: i의 n번 비트가 1인지 아닌지 확인하여 T/F를 반환할 수 있다.  
i의 n번 비트가 1이면 -> 값은 양수다.  
0b0100 & (1<<2) = 0b0100 & 0b0100 = 1  

<음수표현방법>  
컴퓨터는 음수를 2의 보수로 관리한다.  
맨 앞자리 빝트는 음수와 양수를 구분하는 비트  
컴퓨터가 2의 보수를 활용하여 음수를 관리하는 이유: 뺄셈의 연산 속도를 높일 수 있으며 0과 -0을 따로 취급하지 않기 위해  

음수는 첫번째 자리가 1이고, 나머지 자리는 양수로 하여 계산하면 된다.  

2의 보수 구하는 방법  
1. 뒤집는다.
2. 마지막 자리에 1을 더한다.  

2의 보수를 취한 수를 다시 2의 보수를 취하면 원래 값으로 되돌아 온다. -15 -> 15 -> 15

``` python
>>> print(~4)
-5
내 답: 3
```
0b100을 반전해서 0b011이라 3인줄  
msb를 포함해서 만들면 된다.  0b0100 -> 0b1011 -> (-8) + 2 + 1 = 5

양수의 not은 항상 음수다 ->반례: 0과 1

``` python
# 이진수의 끝의 N비트가 모두 1인지 검정하는 함수
def bin_rep(n, m):
    """
    n: 비트
    m: 정수
    """
    for i in range(n):
        # 이렇게 자리수를 조작할 수 있다
        if not 1 & (M >> i):
            return 'OFF'
    return 'ON'
```

##### 실수
소수점 출력방법 f' {t1:.2f} -> 소수점 둘째 자리까지  

파이썬은 c와 달리 float과 double 선택에 걱정하지 않아도 된다.  
내부적으로 더 큰 규모의 자료 구조를 사용하기 때문에

``` python
>>> print(0.1 + 0.1 + 0.1 == 0.3)
False
```
실수는 정확한 값이 아닌 근사값으로 저장한다. 이 때의 오차가 계산 결과에서 다른 결과를 가져온다.

``` python
# 소수가 어떻게 저장되어 있는지 확인하기
def flaot_print(n):
    print(f'{n:.2f}')
    print(f'{n:.20f}')
    print(f'{n:e}')


n = float(input())
flaot_print(n)

"""
0.1
0.10
0.10000000000000000555
1.000000e-01
"""
```

문자열만 한줄로 우다다다 입력되었을 때 자르는 방법: for + 슬라이싱
``` python
n = int(input())
b = 1
b = (1 << n) - 1

if m & b == b:
    return 'on'
else:
    return 'off'
```

msb는 변수 선언할 때 정하는 거임  
보수: 2개를 합쳐 어떤 값이 되는가?  

2진수에서 소수는 제곱을 이용해서 계산한다.  
부호비트 + 자리수비트 + 내용  
실수로 내려간다고 해서 항상 값이 정확해지는 것은 아니다.  
실수를 다룰 때는 
### 오후




















### 알고리즘
``` python
"""
메모리: 58,528kb
실행시간: 165ms
"""
def search_1_square(n, arr):
    """
    n: 배열의 크기(n*n)
    arr: 0과 1로 이루어진 2차원 배열
    return: 1로 이루어진 사각형의 최대 넓이
    """
    max_v = 0

    for col in range(n):
        if max_v > (n-col) * n:
            break                   # for col
        elif '1' not in arr[col]:
            continue
        else:
            i = col
            j = arr[col].index('1')
            output = [0, 0]
            # y축
            while arr[i][j] == '1':
                output[0] += 1
                i += 1

            # y축 다시 초기화하기
            i = col
            # x축
            while arr[i][j] == '1':
                output[1] += 1
                j += 1

            if max_v < output[0] * output[1]:
                max_v = output[0] * output[1]

    return max_v
```

``` python
""" 
메모리: 61,736kb
실행시간: 174ms
"""
def toggle(n, m, arr):
    """
    N: 토글의 크기(n * n)
    M: 초(int)
    arr: 토글의 요소(2차원 리스트)
    return: m초 뒤 arr 에 있는 1의 양
    cnt: 전체 전환하는 횟수
    """
    cnt = 0
    for k in range(1, m+1):
        # m이 k의 배수
        if m % k == 0:
            cnt += 1

        else:
            # 배열 인덱스가 1부터 시작함
            for i in range(N):
                for j in range(N):
                    # 인덱스의 합이 k와 같거나 k의 배수가 되는 영역은 토글
                    if ((i+1) + (j+1)) % k == 0 or ((i+1) + (j+1)) == k:
                        arr[i][j] = abs(arr[i][j]-1)

    num_of_one = 0
    if cnt % 2 == 1:
        for col in range(n):
            if 0 not in arr[col]:
                continue
            for row in range(n):
                if arr[col][row] == 0:
                    num_of_one += 1
    else:
        for col in range(n):
            if 1 not in arr[col]:
                continue
            for row in range(n):
                if arr[col][row] == 1:
                    num_of_one += 1

    return num_of_one
```
### 자습
