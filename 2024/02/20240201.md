# 202402021
## 제목
### 오전
### 오후
### 알고리즘
오늘 풀어 본 문제는 n*n의 격자에서 빈칸을 주었을 때, 가로 세로 단어 퍼즐에서 k의 글자수를 가진 단어가 들어갈 수 있는 경우의 수 발견하는 알고리즘이다.  
최초 내가 구상한 해결 방안은 다음과 같다.  
(사진1)
(사진2)
2차원 리스트를 만들어서 단순히 모든 요소를 확인하는 것보다 끝에 있는 몇 자리는 확인하지 않아도 문제 풀이가 가능하다고 생각한 것이 핵심이다.  
계산 결과 k의 크기에 따라서 n^2의 반복에서 n^2 - (k-1)^2 으로 유의미하게 검사결과가 줄어드는 것을 확인하였고, 입력 가능한 칸에 도달하였을 때, 오른쪽 k-1칸과 아래 k-1칸을 가져와서 분석하는 코드를 구상할 것이다.  
``` python
# 최초 구상한 코드
def word_sapce_in_puzzle(arr, N, k):
    count = 0
    for col in range(N):
        for row in range(N):
            if col<N-k+1 and row<N-k+1:
                if arr[col][row] == 1:
                    # 고민 중

T = int(input())
for t in range(T):
    N, k = map(int, input().split())
    input_lst = [list(map(int, input().split())) for _ in range(N)]
    word_sapce_in_puzzle(input_lst, N, k)
```
고민 중인 부분은 k-1개를 가져올 때, 가져온 요소를 리스트에 넣어서 한 한 번에 검정할 것인가 아니면, 조건문으로 계속 탐색할 것인지 고민이 많이 되었다.












### 자습
