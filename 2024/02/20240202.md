# 20240202
## 점점 좋아지는 듯?
### 오전
오늘은 문제만 하루 종일 푸는 날인 것 같다. 문제가 9개 정도 올라왔는데 다 풀고 갈 수 있을까 하는 생각이 든다.  
예시의 테스트 케이스만 보고 문제를 푸는 것이 아니라 문제를 정확하게 이해하는 것이 중요하다.  
ex) 1 <= a, b <= 5000    -> b가 a보다 클 수도 있다는 것이다. 보이는 테스트 케이스 일부만 보고 판단하지 마라.
그리면서 아이디어를 정리하라.  
코드 짤 때는 주석을 잘 정리할 것
``` python
list1 = [int(input()) for _ in range(P)]
여러 줄을 리스트로 묶는 방법이래
```

테스트 케이스가 1개만 주어졌을 때, 테스트 케이스를 2개로 만들어보거라
오류가 보일 수도 있을 것이다. 

2차원 문제를 풀 때, 1차원으로 먼저 생각을 하고 문제를 풀 수 있도록 하라.

if 가 두 번 붙어 있을 때, and로 묶어라
``` python
# 2차원 리스트에서 0을 붙이는 방법
[list(map(int, input().split() + [0] for _ in range(N) + [[0] * N])]
```

따로 따로 붙어 있는 것을 출력할 때 사용할 만한 것 
``` python
a = [1, 2, 3]
s = ''.join(map(str, a))
print(s)
# 123
```

도형 문제에 아주 약점이 있다고 볼 수 있다. 
연습만이 살 길이다.  
열심히 해보도록 하자.

### 오후
오늘 11시부터 5시 10분까지 6시간 동안 9문제를 풀었다.  
확실히 2차원 문제에서 조건이 붙으면 해결하기 어려웠다.  
하지만 몇 번 풀어본 파리 퇴치 같은 문제는 10분 컷도 가능했다.  
한 번에 코드짰을 때, out of range를 볼 수 없는 경지에 오른다면 리스트 다루는 것은 졸업이라는 생각이 들었다.  

십자 모양으로 벌려 나갈 때 델타를 사용하는데 곱셈을 활용하면 좋다. 
``` python
# 델타를 통해 십자 모양으로 뻗어나가는 방법
if 0 <= col + (di * k) < N and 0 <= row + (dj * k) < M:
    pollen += matrix[col+(di*k)][row+(dj*k)]
```

확실히 들여쓰기를 많이 할수록 검산할 때, 그 순서를 이해하기 어려울 때가 많았다.
``` python
for i in range(N-1):
    count = 0
    j = i
    # 마지막이 1인 경우 잡아내기
    while string[j] == '1':
        count += 1
        if j == N-1:
            break
        else:
            j += 1
    # 방향 확인 필요
    if max_v < count:
        max_v = count
```

풀었던 문제를 하나하나 살펴보니 크게 어려운 기술이나 디테일을 요한 것은 없었다. 다만, 기본에 충실하고 인덱스를 잘 다루면 풀 수 있는 것이 대부분이었다.  
그리고 꽤 오랫동안 붙잡고 있던 퍼즐에 단어넣기 문제도 여러 팁을 들은 끝에 해결하였다. 
그래도 제 시간 안에 문제를 모두 푼 것은 아주 긍정적으로 본다. 다만, 아쉬운 점은 저녁에 요즘 공부를 제대로 못 하는 것은 아주 아쉬운 점이라고 볼 수 있다.
