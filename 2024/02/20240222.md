# 20240222
## 머리 뜨겁네
### 오전
#### start
##### sw 문제 해결
``` python
"""
숫자 하나를 입력받아 2 x 7 행렬에 
첫번째 열: 행이 하나씩 우측으로 갈수록 N을 하나씩 증가시켜 [0:4]까지 입력
두번째 열: 행이 하나씩 좌측으로 갈수록 N을 하나씩 감소시켜 [6:2]까지 입력
"""
N = int(input())
arr = [[0] * 7 for _ in range(2)]

for i in range(2):
    num = N
    for j in range(4):
        if i == 0:
            arr[i][j] = num
            num += 1
        else:
            arr[i][-1-j] = num
            num -= 1
print(arr)
```

우리의 알고리즘 공부의 최종 목적은 코딩 실력을 높이기 위함  
-> 궁극적으로 코딩 테스트 합격이 목표 -> 능숙하게 프로그래밍 언어를 다룰 수 있어야 함

<알고리즘 문제 풀이 과정>
1. 문제의 완전한 이해
2. 종이와 펜을 이용한 설계(어떻게 구현할지)
3. 설계한대로 구현과 디버깅  

내가 가장 못하는 부분은 2번이다.

##### 복잡도 분석
알고리즘: 문제를 해결하기 위한 절차나 방법
ex) 문제 상황: 치킨이 먹고 싶어  
1. 배달 시킨다.
2. 가서 먹는다.
3. 포장한다.  

뭐가 효율적일까?  

공간적 효율성: 연산량 대비 얼마나 적은 메모리 공간을 요하는가?  
시간적 효율성: 연산량 대비 얼마나 적은 시간을 요하는가?  

변수나 리스트를 할당할 때 우리는 메모리를 사용한다.  
시간 복잡도는 반복문을 얼마나 많이 사용했나  

복잡도의 점근적인 표기
1. big o
2. big omega
3. big theta

복잡도가 `f(n) = 2n^2 + 2n + 4` 라면 f(n)의 O 표기는 O(n^2)이다.  

1중 for문은 O(n)
2중 for문은 O(n^2)
여기서 상수의 배수는 하지 않는다.  
상수 for 문은 O(1)  

고의로 상수 배수를 할 수도 있다.  
-> 그래도 미세하게 내 알고리즘이 효율적이다 pr을 위함  

시간 복잡도 O(n)과 O(n^2) 중에 어느 알고리즘의 성능이 좋을까?  
O(n)  
N = 10,000 이면 O(n)은 1만 번 반복할 수 있다고 추정, O(n^2)은 1억번 반복한다고 추정 가능  

알고리즘에서 log의 밑수는 2

O(log N)의 알고리즘에서 N이 10000이면 14번 반복하는 프로그램이라고 상정(올림처리)
O(log N)의 알고리즘에서 N이 100000000이면 27번 반복하는 프로그램

<시간 복잡도 효율성 순서>
O(1) > O(log N) > O(n) > O(Nlog N) > O(N^2) > O(2^N)

pop(0)의 시간 복잡도는 O(n)
why? 맨앞의 것을 지우고 땡겨줘야 하기 때문이다.
popleft() -> O(1)

O(log N) -> 이진탐색 N  
O(Nlog N) -> sort  

값비싼 H/W의 기술 개발보다 효율적인 알고리즘 개발이 훨씬 더 경제적이다.  
-> 효율적인 알고리즘 개발을 위해 사람이 얼마나 갈리는 지 궁금해지는군  

##### 표준 입출력 방법
콘솔 입력보다 더 편리한 파일 입력으로 해야 하는 문제  
py파일이랑  txt파일이 같은 경로로 설정되어 있으면 따로 경로 설정을 해주지 않아도 됨  

과목평가나 swea 등에 제출할 때, sys 모듈은 주석처리하셈  
특히 vsc로 알고리즘 할 때 매우 필요할 듯 하다.   

``` python
"""
파일로 두 수를 입력받아 그것의 합과 곱을 계산하여 output.txt에 입력하는 함수
"""
import sys

sys.stdin = open('input.txt', 'r')
sys.stdout = open('output.txt', 'w')

n1, n2 = map(int, input().split())
print(n1 + n2)
print(n1 * n2)
```

##### 진수
16진수는 2진수를 더 가독성 있게 사용한다.  
16진수는 10진수보다 훨씬 빠르다.

손으로 변환하는 방법 익히기  
프로그래밍으로 진수 변환 구현하기  

2진수 -> 16진수는 연산이 없다.  

0xF9 = 0b11111001  
0xBB3 = 0b101110110011

0b1100101111 -> 0b 0011 0010 1111 -> 0x32F

``` python
# 16진수를 2진수로 바꾸는 함수
input_data = input()
binary = ['0000', '0001', '0010', '0011', '0100', '0101', '0110', '0111', '1000', '1001', '1010', '1011', '1100', '1101', '1110', '1111']
output = ''
for i in range(2, len(input_data)):
    output += binary[int(input_data[i])]

print(output)
```

### 오후
오늘은 진법 문제 위주로 수행하였다.  
11시에 시작하여 4문제를 해결하는데 16시 30분까지 5시간 30분 정도의 시간이 걸렸다.  
이제 IM 대비하여 문제를 다 풀면 다른 연습 문제를 해결하도록 하겠다.  

첫번째 문제는 7자의 2진수를 10진수로 반환하는 문제였다.  
이 문제를 기반으로 이후의 문제를 푸는 것인데 그래도 꽤 손쉽게 해결하였다.  
특히 입력받은 문자열의 인덱스를 건들 때 `[자르는 단위 * 2진수의 수 + 자리수]`으로 계산하면 쉽게 접근할 수 있다.  

``` python
def bit_to_dec(str):
    """
    str: 2진수 (7bit * 10개)
    return: 10진수(lst)
    dec: 7자로 끊은 2진수
    output: 10개의 10진수로 이루어진 반환할 리스트
    """
    output = [0] * 10
    for i in range(10):
        dec = 0
        for j in range(7):
            # 문자열로 저장했으므로
            if str[7 * i + j] == '1':
                dec += 2**(6-j)
        output[i] = dec

    return output
```
두 번째 문제는 16진수를 2진수로 변환하는 문제였다.  
강의에서는 리스트를 통해 해결하는 방안을 제시하였지만, 확실히 딕셔너리가 쉬운 듯 하다.  이 문제도 어떻게 16진수와 2진수를 연결할 것인지 이해만 한다면 비교적 빠르게 해결할 수 있었다.  

``` python
def hex_to_bin(n, hex_num):
    """
    n: 16진수의 자리수(int)
    hex_num: 16진수(str)
    return: 16진수를 2진수로 변환을 한 문자열(str)
    """
    hex_bin_dict = {
        '0': '0000',
        '1': '0001',
        '2': '0010',
        '3': '0011',
        '4': '0100',
        '5': '0101',
        '6': '0110',
        '7': '0111',
        '8': '1000',
        '9': '1001',
        'A': '1010',
        'B': '1011',
        'C': '1100',
        'D': '1101',
        'E': '1110',
        'F': '1111',
    }
    output = ''

    for i in range(n):
        output += hex_bin_dict.get(hex_num[i])

    return output
```

세번째 문제는 조금 어려움을 줬었는데 소수의 이진수를 구하는데 13자 이상이 넘어가면 'overflow'를 출력하는 함수를 만든느 것이었다.  
소수부는 정수부와 다르게 이진수를 구할 때 나누는 것이 아니라 곱하면서 나오는 정수를 이진수에 넣고 나머지를 다시 나누어서 구하는 방식이다. 이것을 수학적으로 이해하진 못 하였지만, 우선 문제를 풀기 위해 적용해보았다. 
``` python
def dec_to_bin(n):
    """
    n: 0부터 1사이의 소수(float)
    return: 십진수에서 변환한 이진수의 소수점 이하 자리(str, 13자 이상 넘어갈 시 0반환)
    """
    output = ''
    cnt = 0

    while n != 0 and cnt < 13:
        output += str(n * 2)[0]
        n = float('0.' + str(n * 2)[2:])
        cnt += 1

    if cnt >= 13:
        return 'overflow'
    else:
        return output
```
확실히 수학적 개념이 잡혀있지 않다보니 어려움을 겪었다.  

오늘 이렇게 시간을 사용하게 한 원흉이다.  
문제를 이해하는 데도 많은 시간이 소요되었고, 디버그에도 많은 시간을 썼다.  
확실히 이런 문제는 빠르게 문제를 이해하는 것이 중요해 보이고,  
문제를 해결하기 위해 그림을 활용하는 것이 매우 바람직하다.  

그리고 알기 쉬운 절차로 진행을 하는 것이 필요하다. 
슬슬 IM 검정이 다가오다보니 많은 시간을 쓸수록 초조해지는데 너무 급하게 하지 않아야 한다.  
물론, 한 큐에 A까지 뽑으면 좋지만, 과욕은 지금의 내 능력도 떨어뜨린다.  

``` python
def simple_bin_cipher_code(N, M, arr):
    """
    N: 암호의 길이(int)
    M: 문자열의 행 길이(int)
    arr: 암호의 배열(2차원 리스트)
    return: 암호코드의 해석(int, 올바르지 않으면 0)
    """
    code_dict = {
        '0001101': 0,
        '0011001': 1,
        '0010011': 2,
        '0111101': 3,
        '0100011': 4,
        '0110001': 5,
        '0101111': 6,
        '0111011': 7,
        '0110111': 8,
        '0001011': 9,
    }

    code_lst = []
    col = 0
    while '1' not in arr[col]:
        col += 1

    row = -1
    while arr[col][row] == '0':
        row -= 1

    # 앞부터 뽑아서 할 순 없는 것인가?
    for i in range(8):
        tmp = ''
        for j in range(7):
            tmp += arr[col][row-j]
        code_lst.append(tmp[::-1])
        row -= 7

    # 숫자로 변환합니다.
    for i in range(8):
        code_lst[i] = code_dict.get(code_lst[i])
    
    # 암호 해독
    v1 = sum(list(map(lambda x: x * 3, code_lst[1:8:2])))
    v2 = sum(code_lst[0:7:2])

    # 암호 유효성 확인
    if (v1 + v2) % 10 == 0:
        return sum(code_lst)
    else:
        return 0
```
처음에는 한 번에 앞에서부터 검색하면서 값을 반환하려고 했는데 뒤에서 보면 모든 암호가 '1'으로 시작한다는 사실을 알았고, 암호를 깔끔하게 찾을 수 있다는 것을 알았다.  
그리고 col은 1이 있는 열을 하나 뽑아서 진행하면 되고 암호 해독은 쉽고, 간단하게 진행할 수 있었을 것 같은데 아쉬움이 있다.  

### 자습
