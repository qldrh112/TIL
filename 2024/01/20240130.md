# 20240130
## 이제 슬슬 밀려온다.
### 오전
#### 카운팅 정렬
항목들의 순서를 결정하기 위해 각 집합에 항목이 몇 개씩 있는지 세는 작업을 해 선형 시간에 정렬하는 알고리즘
<제한 사항>  
- 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능  
ex) [2, 2, 1, 3, 5, 2] ->2는 3개, 1은 몇 개 , 뭐는 몇 개 이런 식으로 얻어내는 것  
- 카운트를 위한 충분한 공간을 할당하려면 집합 내 가장 큰 정수를 알아야 한다.  
<시간 복잡도>  
O(n+k) n은 리스트 길이, k는 정수의 최대값  

[0, 4, 1, 3, 1, 2, 4, 1]을 카운팅 정렬하는 과정  
> 1단계를 잘 이해하라

`counts = [0] * (k+1)`
정수의 수만큼 리스트를 만든다.

```python
for x in data:
    counts[x] += 1
```

흔히 많이 하는 실수  
data를 50개를 받았는데 counts도 50개를 만들어버리는 경우  

누적된 개수를 만들어버리는 경우도 있다.  
[0, 4, 1, 3, 1, 2, 4, 1]

0 -> 1  
1 -> 4  
2 -> 5  
3 -> 6  
4 -> 8  

어떻게 하냐?  
``` python
for x in data:
    counts[x] += 1

for i in range(1, K+1):
    counts[x] += counts[x-1]

```

누적합에서 기본합을 구하는 방법  
누적합 인덱스 3에서 0을 빼라
그러면 누적합 1과 2 사이에 값이 나옴
for 문을 data에서 까꾸로 돌면서 

counts[i]을 감소시키고, counts[i]의 값을 temp 인덱스로 삼아서 1을 삽입한다.
결과로 temp에는 정렬된 순서로 기록이 된다.  

배열에 숫자를 누적하는 것도 많이 쓰이는 기술이다.

그런데 왜 배열 뒤에서부터 정렬을 하냐?  
그래야 원래 배열이 그대로 유지가 된다.  
앞에서부터 하면 (1, 2), (1, 3), (1, 4) 배열이 뒤죽박죽된다.

#### baby-gin game
run - 3장의 카드의 숫자가 연속된다
triplet - 3장의 카드의 숫자가 중복된다.

<해결 방법>
1. 완전 검색: 모든 경우의 수를 나열하고 확인하는 기법  
생각보다 모든 경우의 수를 나열하는 것이 쉽지 않다. 
- 수행 속도가 느리다.
- 해답을 찾을 확률이 높다.
- A형 정도까지는 완전 검색으로 털어칠 수 있다.

고려할 수 있는 모든 경우의 수 생성하기
n개의 숫자로 만들 수 있는 모든 순열 나열
ex) 2 3 5 7 7 7
    2 5 3 7 7 7
    3 2 5 7 7 7  이하 생략 총 6!

숫자 3개로만 순열을 만들어라? -> 우리한테도 이지 머니다.  
3개의 for문을 통해 각 요소를 겹치는 지 확인해서 겹치지 않으면 조합에 넣으면 된다.

그런데 이거 너무 길고 복잡하다.  
다른 방법이 없을까?  

2. 탐욕 알고리즘
하나를 결정할 때마다 그 상황에서 최적이라고 생각하는 것을 선택 -> 결과도 최적이 아닐까?  
초반 스노우볼 같은 느낌

ex) 거스름돈 줄이기
손님한테 거스름돈을 준다고 하면 동전 개수를 줄이기 위해 금액이 가장 큰 동전을 준다.
800원을 거슬러 줘야 함 -> 우선 500원 주고 생각해 -> 300원 남았네? -> 100원으로 3장 털까?
만약 500원짜리 동전과 400원 짜리 동전과 100원짜리 동전이 있다고 하면  
탐욕기법으로는 400원 2개를 주지 않는다. 
완전검색은 500으로 시작해보고, 400으로도 시작해보고, 100으로도 해보고 좋은 걸 찾는다.  

triplet -> run  
run -> triplet  
으로 탐색 순서도 정해놔야 한다. 보드게임에 기본 전략이기도 하다.  

``` python
num = 456789
c = [0] * 12 # 카운트 배열, 왜 6자린데 12자리를 만드나요? 

for i in range(6):              # 자리수를 모를 때 -> while num > 0:
    # 각 자리 수를 따는 방법
    c[num % 10] += 1
    num // 10

```
index 10과 11, 2개의 더미를 활용해 추후 활용  
`tri = run = 0` 이런 표현도 되는구나   
> 반복문에서의 연산은 조건 연산이든 뭐든 줄이는 것이 좋다.

리스트의 길이(N) - 구간리스트의 길이(M) + 1 =
``` python
for i in range(0, N-M+1): 10-3 = (0~8)
    for j in range(0, M) 
```
빈 리스트를 만들어놓고 막 추가하는 것은 지양해라
슬라이싱을 하는 데 깊은 복사가 된다고?
append는 자제해라 -> 왜 why? append는 시간을 잡아먹을 수 있기 때문에 append를 수행하면 리스트를 복사하고, 크기를 늘리기 때문에

우와, 이거 개편이 필요하겠는 걸?

<출력값과 비교하는 방법>
1. diffchecker - 내 출력과 tc의 출력이 같은지 확인하는 것
2. 
```python
import sys
sys.stdout = open('output_view.txt, 'w')
```

초기값은 항상 0으로 하는 것이 아니라 다른 변수로 해서 바꿔치기 하는 것을 볼만하다.

실행 시간은 100ms 정도면 차이 없다.
3min과 100ms 정도 차이면 크다.

### 오후
split은 붙어 있는 경우에는 사용이 어렵다.
확실히 알고리즘에 익숙하지 않아 코드 리뷰를 작성하며 진행하기 어려운 부분이 있다. 빠르게 치고 올라가서 여유롭게 코딩하고, 체력 안배를 할 수 있게 만들어 놓아야겠다.

가장 어려운 문제는 상자를 평탄화하는 문제인데 함수 사용에 제약이 있어서 그런지 아직 불편하게 문제를 푸는 느낌이다. 사실 메모리나 동작 시간을 고려하면서 푸는 방법을 익히는 것이라고 생각하고 임하는데 쉽지는 않다.  
내가 생각한 것은 순차적으로 배열하면서 음수인덱스와 양수인덱스를 조화해가면서 푸는 것인데 생각보다 쉽지는 않다.



### 알고리듬

```python
def show_grade(arr, N, k):
    """
    param(arr): 학생들의 점수 리스트
    param(N): 학생의 수 
    param(k): 처음 받은 리스트에서 몇 번째 학생의 등급을 반환할 것인지

    학생의 점수를 리스트로 받아, 기준에 따라 총점을 만들고,
    인덱스를 키로 점수를 딕셔너리로 만듭니다. 
    이후, 학생들의 점수를 내림차순으로 배열해 등급을 부여합니다.
    학생들의 점수와 등급을 튜플로 묶습니다.
    그리고 원하는 인덱스로 등급을 뽑아내 반환합니다.

    {인덱스: 점수}, (점수, 등급) -> 인덱스(k)를 통해 점수를 얻어내고, 그 점수로 등급을 얻어내는 원리
    """
    gpa_list = []
    gpa = sum(map(lambda x, y: x * y, arr, [0.35, 0.45, 0.2]))
    gpa_list.append(gpa)

    for i, gpa in enumerate(gpa_list):
        idx_gpa = {
            i : gpa
        }
    
    grade_list = list(map(lambda x, arr: x * arr, N//10, ['A+', 'A0', 'A-', 'B+', 'B0', 'B-', 'C+', 'C0', 'C-', 'D0']))
    
    sorted_gpa_list = sorted(gpa_list, reverse=True)
    gpa_grade_list = zip(sorted_gpa_list, grade_list)

    for tup in gpa_grade_list:
        gpa, grade = tup
        if gpa  == idx_gpa.get(k):
            return grade
        

T = int(input())
for t in range(T):
    N, k = map(int, input().split())
    input_list = list(map(int, input().split()))
    print(f'#{t+1} {show_grade(input_list, N, k)}')
```
문제 발생 1: 등급을 매긴 람다함수에서 정수는 iterable이 아니다.

```python
lambda x, arr: x * arr, N//10, ['A+', 'A0', 'A-', 'B+', 'B0', 'B-', 'C+', 'C0', 'C-', 'D0']
```

map과 list 쳐내라

문제 발생 2: None을 반환한다.
이거 학생 한 명 점수 입력하면 바로 값이 리턴되네

``` python
input_list = [0] * N
for n in range(N):
    input_list[n] = list(map(int, input().split()))
```

오늘 배운 거 바로 써먹어주면서 ~

문제 발생 3: 실수는 곱하기 연산이 되지 않는다.
```python
gpa_list = []
    for i in range(len(arr)):
        gpa = sum(map(lambda x, y: x * y, arr[i], [0.35, 0.45, 0.2]))
        gpa_list.append(gpa)
```

이래도 None이 나오네
``` python
for i, gpa in enumerate(gpa_list):
    idx_gpa = {
        i : gpa
    }
```
이 양반이 발목을 잡았네

``` python
idx_gpa = {}
for i, gpa in enumerate(gpa_list):
    idx_gpa.update({i : gpa})
```
업데이트를 사용하거라

문제 발생 4 : 람다를 사용하니까 점수와 매핑이 코딱지 같이 된다. 
[(99.45, <function show_grade.<locals>.<lambda> at 0x0000026294D82E80>), (96.25, 1), (92.55000000000001, ['A+', 'A0', 'A-', 'B+', 'B0', 'B-', 'C+', 'C0', 'C-', 'D0'])]

``` python
    grade_list =  N//10 * ['A+', 'A0', 'A-', 'B+', 'B0', 'B-', 'C+', 'C0', 'C-', 'D0']
```

제출을 했는데 코드는 잘 돌아가나 이상한 답이 튀어나와서 fail을 맞아버렸다. 그래서 원인을 살펴보니
``` python
['A+', 'A0', 'A-', 'B+', 'B0', 'B-', 'C+', 'C0', 'C-', 'D0'] * (N//10)

# 이후에 점수를 높은 순으로 던져줘야 하는데 그렇지 못 해서 날라갔다.    
```