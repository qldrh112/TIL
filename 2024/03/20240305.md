# 20240305
## 느슨한 시간
### 오전
#### 기초 논리 & 수학
##### 서론 - 프로그래밍과 논리/수학
hard logic과 soft logic  
맥주집 문제를 풀 때 우리는 직관을 사용함  
직관은 익숙한 상황에서 빠르다. 하지만, 단점은 정확하지 않고 착각을 일으킴  

합격하려면 토플 500점 이상 혹은 토익 600점 이상이 필요  
-> 2가지 중 하나 -> inclusive OR
복권에 당첨되면 자동차 혹은 천만원을 줍니다.  
-> 2가지 중 하나 -> exclusive XOR  

논리는 주장을 뒷받침하는 근거를 보조하는 것  
이치: 과정의 순서가 올바르게 연결되었다.  
논리: 이야기의 이치  

논리학에서 중요한 것: 형식  
p이면 q이다.  
-> 명제: True / False 판단  
우체통을 빨갛다 -> 명제  
나는 잘 생겼다 -> 명제 -> 참/거짓을 나눌 수 있으므로
운동 같이 하실래요? -> 명제x -> 의문문  
밥 좀 먹어라 -> 명제x -> 명령문  

도전 과제  
1. T
2. T
3. X (의문문)
4. X (명령문)
5. T
6. T

난 강아지를 키운다의 부정인 '난 강아지를 키우지 않지.'의 의미?  
선지에 정답 없음  

주장의 부정은 주장을 제외한 모든 가능성을 내포함  

명제의 두 가지 전제
- 배중률: T/F의 무조건 값을 가지는 것  
ㅇㅇㅇ: 무조건 False는 아니다. ->  True  
- 모순율: True와 False 동시에 성립  

이기다의 부정: 이기지 않다.  
이기다의 반대: 지다.

민철이는 제주도에 간 적이 없다. -> 있지는 않다.
코코는 뉴욕에 산다. -> 살지는 않는다.
라면에는 마늘을 항상 넣어서는 안 된다. -> 넣어야 하지는 않는다.  
도현이는 지나치게 많이 먹지 않는다. -> 먹지는 않는다.  

참인 명제를 부정하면 거짓이 된다.  
한국의 수도는 서울이 아니다.  
-> 한국의 수도는 서울이다.  

한국의 수도는 뉴욕이다.  
-> 한국의 수도는 뉴욕이 아니다.  

or은 2가지  
- inclusive OR 
- exclusive XOR  

exclusive Xor은 교집합을 제외한 나머지 부분

시험 100점을 맞으면 치킨을 사주겠다고 함  
근데 100점을 못 받았는데 치킨을 사줬다 -> 왜why? 약속을 어긴 것이 아니므로(배중률)  

가정이 거짓이면 전체는 항상 참이 된다.  
100점을 맞지 않았을 때, 사주든, 사주지 않든 명제의 바깥이다.  

- 가정명제가 거짓이면 전체명제식은 참이다.  
- 대우명제가 참이면 전체명제식도 참이다.

명제: 강아지는 포유류이다.  
역: 포유류는 강아지이다. (p와 q를 뒤집어라)  
이: 강아지가 아니면 포유류가 아니다. (p와 q를 부정해라)
대우: 포유류가 아니면 강아지도 아니다. (역과 이를 동시에 수행)  

만약 0이 홀수라면, 미국에서 2080년 월드컵이 열린다. -> 참(왜? 가정 자체가 거짓이므로)
만약 3928104810928490이 prime number라면 2는 짝수이다. -> 참(왜? 그 식의 대우인 '2가 홀수이면 341920343이 소수가 아니라는 것은 참이므로)  

p -> q가 거짓이라고 하면 p는 반드시 true(p가 거짓일 때 전체 명제는 참이므로) q는 false(p가 참이므로) 
1. ~p -> q 참
2. p v q 참
3. q -> p 거짓

배타적 논리합의 진리표는 or의 반대가 맞다.  

##### 논리와 증명
연산자 우선 순위: not -> V, ^ ->  ->, <->

참 증명 방법:
1. 조건이 F인가?
2. 결과가 T인가?
3. 대우가 T인가?

명제도 결합법칙, 분배법칙 등이 있다. 

거짓은 반례를 하나라도 보여주면 된다.  

뒤집어진 Ax는 all of x  
뒤집어진 Ex는 어떤 x

n^2이 3의 배수이면 n을 3의 배수임을 증명하라.
![20240305_오전과제_이규석_240305_114241_1](https://github.com/qldrh112/TIL/assets/69291489/d8979955-2c51-4cd5-8227-307cb3c0a85e)
![20240305_오전과제_이규석_240305_114241_2](https://github.com/qldrh112/TIL/assets/69291489/3a72897e-02f8-4aca-a39a-2cb86c0b0e34)


##### 수와 표현
소수부 이진수와 지수만 저장을 하면 편리하지 않을까?  
log를 왜 씀? 숫자를 작게 다루기 위해서.. 지수만 쓰니까 
x = log n 과 2^x = n 은 같은 말

2^x = k, x = log k  

문제2: 스무고개가 이상적으로 진행된다고 할 때 맞출 수 있는 답의 종류는?

##### 집합과 조합론
()를 이용해 조합을 표현할 수 있다.  
8 x 8 에 보드판에서 겹치지 않게 2개를 두는 경우 64 * 63 / 2  

0부터 9의 수로 4~6자리의 비밀번호를 만드는 개수  
10C4 + 10C5 + 10C6 = 10C5 + 2(10C4)  

52개의 카드를 이용해서 만들 수 있는 5개 카드의 조합은?  

52C5 = 2,598,960  

5장 중 같은 무늬 3장 + 다른 무늬 2장  
-> 4C1 * 13C3 + 3C2 * 13C1 * 13C1  

x + y + z = 100의 자연수 해는 무엇인가?  
공이 100개가 있는데 그것을 3개의 바구니에 나눠 담는 경우로 생각하면 된다.  

52개 카드에서 5개 카드 조합을 만들 때 숫자가 같은 카드가 한 쌍도 없는 경우  
52C1 * 48C1 * 44C1 * 40C1 * 36C1  

13C5 * 4^5(4개의 무늬 중 5개 고르기)

##### 기초 수식
시간 복잡도 계산  
다음 재귀식을 O() notation 수준으로 풀어라(O표기법으로 풀어라)
문제1: T(n) = T(n - 1) + 1 / T(0) = 1  
T(n-1) = T(n-2) + 1  
T(n) = T(n-2) + 1 + 1 = T(n-2) + 2  
T(n-2) = T(n-3) + 1  
T(n) = T(n-3) + 3  = T(n-k) + k  
= T(0) + n  
= O(T(n)) = O(n)

문제2: T(n) = T(n-1) + n, T(0) = 1  
T(n-1) = T(n-2) + n-1
T(n) = T(n-2) + n-1 + n  
T(n-2) = T(n-3) + n-2 + n-1 + n = T(n-k) + (n-(k-1)) + .. + n
T(0) 만들기 위해 k = 7 대입
T(0) + 1 + 2 + 3 + ... + n
1 + n(n+1)/2 => O(n2) 상수 배수는 제거함  

문제3: T(n) = T(n-1) + log n, T(0) = 1
T(n-1) = T(n-2) + log(n-1)
T(n) = T(n-2) + log(n-1) + log(n)  
<= T(n-2) + nlogn  
<= T(n-k) + nlogn  
<= T(0) + nlogn = nlogn + 1  
O(T(n)) = O(nlogn)

문제4: T(n) = T(n/2) + 1, T(1) = 1  
T(n/2) = T(n/2^2) + 1  
T(n) = T(n/2^2) + 2
T(n/2^2) = T(n/2^3) + 1
T(n) = T(n/2^2) + 3 = T(n/2^k) + k  
T(1)을 만들기 위해 2/2^k가 1이 되어야 함  
n = 2^k  
k = log n  
= logn + 1
O(T(n)) = O(logn)

빅오메가: 잘해봤자.  
빅세타: 항상 일정하게(상수와는 다름)  
n은 입력의 크기, 범위, 개수

### 오후
##### 재귀
##### 동적 프로그래밍
위의 두 개 영역은 생략하였다.  

### 자습
### 알고리즘
이전 알고리즘 첫 시간에 풀었던 문제다. 당시에는 어떻게 풀었는지 살펴보도록 하자.  

건물의 위치에 따라서 수집하는 인덱스를 다르게 했다.  
다만 아쉬운 부분은 앞에서 2개, 뒤에서 2개의 건물은 건물이 없으므로 다 쳐내고, else문만 추가하면 될 듯 하다.  
neighbor에서 가장 큰 놈과 i건물의 차만큼 조망권을 더해라  
이렇게 조금 직관적으로 구성되어 있다.  
max_num은 max함수 사용이 불가능해서 추가한 듯 하다.  
``` python
# 1월 29일 작성 코드
"""
메모리: 60,564kb
실행시간: 160 ms
"""
def max_num(arr):
    for i in range(len(arr), 1, -1):
        for j in range(i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    return arr[-1]
 
 
def have_view_house(arr, N):
    """
    :param arr: 각 건물의 높이 리스트
    :return: 조망권이 확보된 세대의 총합
    """
    output = 0
    for i in range(N):              # 0~99 #n=100
        # 범위에 따라서 이웃세대의 리스트가 달라진다.
        # 이거 오류처리로 짧게 끊을 수 있는 방법 없나?
 
        if i == N-2:
            neighbor = [arr[i-2], arr[i-1], arr[i+1]]
        elif i == N-1:
            neighbor = [arr[i-2], arr[i-1]]
        elif i == 1:
            neighbor = [arr[i+1], arr[i+2], arr[i-1]]
        elif i == 0:
            neighbor = [arr[i+1], arr[i+2]]
        else:
            neighbor = [arr[i - 2], arr[i - 1], arr[i + 1], arr[i + 2]]
 
        # 이웃 세대 중 가장 큰 세대와의 차이만큼 조망권이 확보된다.
        if arr[i] > max_num(neighbor):
            output += arr[i] - max_num(neighbor)
 
    return output
```
1달 정도 지나니 코드가 꽤 간략해졌다.  
검사하기 원하는 건물을 기준으로 -2 ~ 2개의 건물과의 높이 차리르 비교하여 4개 건물 모두가 검사하는 건물보다 낮다면 차가 가장 작은 것을 추가하는 함수이다.  

아쉬운 점은 모든 건물을 검사하여 꽤 많은 시간이 소요된다는 것이었다. 
``` python
# 1차 시도
"""
메모리: 63,312 kb
실행시간: 198 ms
"""
def view_check(lst):
    cnt = 0
    # 건물이 있는 곳을 기준으로 2개 비워져 있으니 n-2
    for i in range(2, N-2):
        # 좌우 2개의 세대와의 높이 차 확인
        tmp = [lst[i] - lst[i + j] for j in [-2, -1, 1, 2] if lst[i] - lst[i + j] > 0]
        # 하나라도 음수면 다 쳐내라
        if len(tmp) == 4:
            cnt += min(tmp)
    return cnt
```

메모리와 실행 시간을 줄이기 위해서 코드를 조금 수정해보았다.  
이웃 집을 조사하다가 옆집높이가 크거나 같으면 반복문을 종료해보았는데 이거 가지고는 유의미한 결과를 만들지 못하였다. 
```python
# 2차 시도
"""
메모리: 63,044 kb
실행시간: 197 ms
"""
def view_check(lst):
    cnt = 0
    # 건물이 있는 곳을 기준으로 2개 비워져 있으니 n-2
    for i in range(2, N-2):
        # 최대 높이 255
        tmp = 255
        flag = True
        for j in [-2, -1, 1, 2]:
            tmp = min(tmp, lst[i] - lst[i+j])
            # 옆집 높이가 더 크거나 같으면
            if lst[i] - lst[i + j] <= 0:
                flag = False
                # for j
                break
        if flag:
            cnt += tmp
    return cnt
```
### 자습
오늘부터 적어도 하나은행 자기소개서 항목을 하나씩 작성하기로 하였다.  
오늘은 4번이 잘 구상되어서 작성하였는데 쓰다보니 전개가 매끄럽게 흐르지 않는 부분이 있어서 그것을 고치느냐 꽤 시간이 소요되었던 것 같다.  
그래도 내가 하고 싶은 말은 다 적어넣어서 다행이다.