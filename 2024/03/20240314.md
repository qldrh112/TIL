# 202403
## 제목
### 오전
### 오후
### 알고리즘

``` python
# 02월 07일 작성 코드
"""
메모리: 43,788 kb
실행시간: 111 ms
"""
def password_rule(num_lst):
    """
    params N: 숫자열의 길이
    param numbers: 숫자열 리스트
    """
    # 임시 변수 trash_bin과 스택의 맨 위 top으로 지정
    trash_bin = []
    top = -1
     
    while len(num_lst) > 1:
         
        # 연속된 숫자는 제거
        if num_lst[top] == num_lst[top-1]:
            num_lst.pop(top)
            num_lst.pop(top)
             
            # trash_bin에 무언가 있으면 num_lst로 이전
            if len(trash_bin) > 0:
                num_lst.append(trash_bin.pop(top))
         
        # 연속되지 않은 숫자는 trash_bin으로
        else:
            trash_bin.append(num_lst.pop(top))
     
    # num_lst에 남은 거 trash_bin의 가장 뒤로 이동
    # trash_bin = [4, 3, 2, 1]
    trash_bin.append(num_lst.pop(-1))
     
    # trash_bin을 역순으로 돌림
    # trash_bin = [1, 2, 3, 4]
    trash_bin = [trash_bin[x] for x in range(len(trash_bin)-1, -1, -1)]
     
    return trash_bin
 
for t in range(10):
    N, numbers = input().split()
    numbers = list(numbers)
    # 출력합니다.
    print(f'#{t+1}', ''.join(password_rule(numbers)))
```



``` python
"""
메모리: 58,248 kb
실행시간:145 ms
"""
def search_password(n, nums):
    """
    params n(int): 문자열의 길이
    params: nums(str): 암호
    """
    stack = []
    for i in range(n):
        # 스택이 비어있을 때
        if not stack:
            stack.append(nums[i])
        # 스택의 마지막과 같을 때
        elif stack[-1] == nums[i]:
            stack.pop()
        # 스택의 마지막과 같지 않을 때
        else:
            stack.append(nums[i])

    return stack


for t in range(1, 10+1):
    N, input_nums = input().split()
    print(f'#{t}', ''.join(search_password(int(N), input_nums)))
```
### 자습