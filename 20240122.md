# 20240122
## 체력 보충 완료
### 오전
#### Data Structure
여러 데이터를 상황에 따라 효과적으로 유연하게 사용하기 위해 관리하는 구조
자료 구조: 각 데이터의 효율적인 저장, 관리를 위한 구조를 나눠놓는 것

##### 메서드 
함수이며 하나의 객체
클래스는 파이썬에서 타입을 표현하는 방법
> '.'은 속한다는 것을 의미


`__메서드 이름__` : 매직 메서드로 사용자가 아닌 파이썬이 동작 중에 활용하는 메서드  
`__append__` 는 리스트 클래스 안에 내부적으로 정의되어 있는 함수  
딕셔너리와 문자열에서는 `__append__`라는 메서드가 정의되어 있지 않아 사용이 불가능하다.  
`list.appned(object)` 다른 함수와 기능적으로 차이가 없는 일반 함수  
`객체.메서드()`로 사용하고 있다.

메서드는 어딘가에 속해있는 함수

#### 시퀀스 데이터 구조
##### 문자열
> 문자열 탐색 기법 등 새로운 것을 배울 때, 그것의 쓰임새를 한 번 고민해보았으면 한다.

|**문자열 탐색**|**설명**|
|:------:|:---:|
|s.find(x)|x의 위치 반환, 없으면 -1 반환|
|s.index(x)|x의 위치 반환, 없으면 error|
|s.isalpha()|문자열의 제일 앞이 유니코드 상 letter 확인|
|s.isupper()|대문자 여부|
|s.islower()|소문자 여부|

is로 시작하는 메서드는 십중팔구 return이 bool값이다.


|**문자열 조작**|**설명**|
|:------:|:---:|
|s.replace(old, new[,count])|바꿀 대상 글자를 새로운 글자로 바꿔서 반환|
|s.strip([chars])|문자열의 시작과 끝에 있는 공백 혹은 지정한 문자를 제거|
|s.split|지정한 문자를 구분자로 문자열을 분리하여 문자열의 리스트로 반환|
|'구분자'.join(iterable)|반복 가능한 요소를 원래의 문자열을 구분자로 이용하여 하나의 문자열로 연결|


문자열 조작 메서드는 새로운 문자열을 반환하는 것이다.  
왜 why? 문자열은 원본을 조작 불가능하기 때문이다.

함수 인자 설명에서 '[]'가 있는 경우가 있을 것  
물론 이것은 파이썬의 표기법은 아니다.  
하지만, 이것은 모든 프로그래밍 언어의 표기법이다.(배커스-나우르 표기법)  
세상에 많은 프로그래밍 언어가 있는데 그것의 문법은 상이하다.
함수 설명의 표기법을 하나로 통일하였다.  
파이썬은 확장된 배커스-나우르 표기법(EBNF)을 사용한다.
EBNF에서 대괄호는 `optional`을 의미한다.

`변수.swapcase().replace('l', 'z')`와 같이 이어서 사용 가능하다.  
단, 앞의 메서드가 None이거나 값을 받을 수 없는 경우 오류가 발생한다.

##### 리스트
> 추후 스택이나 큐, 힙 등의 자료 구조 이해를 위해서라면 반드시 이하 내용을 숙지하도록 하자.

.appned(x)  리스트 마지막 요소에 x를 추가  
.extend(iterable) 리스트에 다른 반복 가능한 객체의 모든 항목을 추가

리스트는 문자열과 달리 가변 데이터 타입이므로 원본이 변경된다.  
`print(my_list.append([10, 9, 8]))` # None -> 원본을 변환하는 것은 따로 return이 없으므로 None을 반환한다.

`.insert(i, x)` 리스트에 지정한 index에 항목 x를 삽입  
`.remove(x)` 리스트에서 가장 앞에 위치한 x를 삭제  
``.pop(i)`` 리스트에서 지정한 인덱스i의 항목을 제거하고 반환, 작성하지 않을 경우 마지막 항목을 제거  
``.clear()`` 리스트의 모든 요소를 삭제, 리스트 자체를 날리는 것은 아니다.  
`.index(x, start, end)` 가장 왼쪽에 있는 항목 x의 인덱스를 반환
`.reverse()` 리스트의 순서를 역순으로 변경(정렬x)
`.sort()` 리스트를 정렬 오름차순이 기본 (매개변수 사용 가능) -> 원본을 바꾸므로 반환이 없다.
`.count(x)` 리스트에서 항목 x의 개수를 반환

``` python
my_list = [3,2,1]
sorted_list = my_list.sort()
print(sorted_list) # None
```
이런 실수를 대단히 많이 한다.  

모든 메서드를 외울 수 없으니 몇 가지 필수적인 메서드만 사용법을 외워놓고 나머지는 필요할 때 찾아서 사용하도록 한다.

#### 복사
파이썬은 데이터의 분류에 따라서 복사 여부가 달라진다.  
변경 가능한 데이터 타입과 변경 불가능한 데이터 타입을 다르게 다룬다.

``` python
a  = [1, 2, 3, 4]
b = a

b[0] = 'b만의 요소'

print(a) #['b만의 요소', 2, 3, 4]
print(b) #['b만의 요소', 2, 3, 4]
```
오, 참으로 놀라운 일입니다.  
왜냐하면 이는 우리가 가진 할당의 인식과 다르게 같은 주소를 할당하는 것이기 때문에

``` python
a = 1000000000000000000000000000000000000000000000000000
b = a 

b = 0

print(a) # 1000000000000000000000000000000000000000000000000000
print(b) # 0
```
아니 이건 왜 바뀜?  
문자열과 정수는 변경 불가능한 자료 데이터 타입이기 때문이다.

##### 할당
리스트 전체에 대한 주소도 존재하고 리스트의 각 요소의 주소도 존재한다. 즉, 할당 이후의 요소 변화에는 전체 리스트의 참조 주소가 변하지 않으므로 이런 현상이 발생한다. 
> 할당과 복사가 이해가 되지 않는다면 추가적인 공부를 할 수 있도록 하자

##### 얕은 복사
``` python
a = [1,2,3]
b = a[:]
b[0] = 100

print(a) #[1,2,3]
```

한계: 2차원 이상의 리스트는 사람이 생각하는 복사가 되지 않는다.

##### 깊은 복사
copy 라는 모듈을 통해서 깊은 복사를 수행할 수 있다.
`copy.deepcopy` 메서드를 통해 완전히 독립적인 리스트로 새로 할당을 해준다.

#### 참조
- isdesimal() 문자열의 모두 숫자로 이루어져 있는가?
- isdigit() .isdesimal() + 유니코드 숫자까지 포함
-  isnumeric() .isdit() + 루트 등 수학적인 기호까지 포함

#### 시험 리뷰
print(3.0 + 2) # 5.0
암시적 형변환과 명시적 형변환 > 형변환은 각 요소에서 인식한다.
모듈: 독립된 파이썬 파일(.py)
> 자신감과 거짓말을 분명하게 구별할 필요가 있다. don't rule get broken

### 오후
- dict.get(key)는 딕셔너리에서 key의 value를 찾아서 값을 반환하는 메서드이다.
- dict.get(key)로 당겨왔을 때 key가 dict에서 탐색되지 않으면 None을 반환한다.
- class 의 첫 메서드는 생성자 메서드인 ``__init__``으로 하도록 하자.
- 클래스 변수는 클래스의 네임 스페이스에 존재하는 변수를 의미하고 인스턴스 변수는 클래스의 메서드에 존재하는 self 이후의 
- `dir`은 해당 자료형이 갖는 메소드를 설명한다. 그것을 리스트로 감으면 메서드 이름 내역을 알 수 있다. 
- 스태틱 메서드: `@staticmethod` 데코레이터를 사용해서 클래스에 메서드를 선언한 것 -> 정적 메서드는 첫번째 매개 변수가 할당되지 않음 -> 단순한 동작만을 처리한다.