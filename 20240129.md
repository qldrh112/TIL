# 20240129
## 한 문제만 더 풀었다면


### 오전
시험을 봤는데 재귀함수로 10진수를 2진수로 바꾸는 문제에서 고전하였다.  
어떻게 재귀함수로 접근해야 할 지 감도 오지 않았다.  
그렇게 시험이 끝나고 약 10분 정도 머리를 싸맨 끝에 재귀함수와 return을 이해해버렸다.  
지난 시간에 배운 콜 스택을 활용하여 늦게 호출된 것이 값을 먼저 뿌린다는 것을 이해할 수 있는 좋은 기회였다. 사실은 저번에 배우고 바로 공부해서 시험에서 그것을 발휘하는 것이 목표였을텐데 말이다 어쨌든
```python

def func(n):
    
    if n // 2 > 2- 1:
        # 숫자 n의 몫이 k진수의 k값보다 크면 함수를 계속 돌리고, 나머지만 뒤에 따라오게 합니다.
        return f'{func(n//2)}{n%2}'
    else:
        # 숫자 n의 몫이 k진수의 k값보다 작으면 그 몫과 나머지를 차례로 출력합니다.
        return f'{n//2}{n%2}'
```

내일부터 본격적으로 진행하기 위해 파이참과 pypi를 설치하였다. sw검정에서 파이참을 사용한다고 하니 파이참에 조금은 익숙해질 필요가 있을 것이라고 생각한다.

다른 언어는 변수를 생성할 때 자료형을 지정해야 하기 때문에 알고리듬 문제에서 범위를 지정해주곤 한다.

파이썬에게 불필요해 보이는 정보는 다른 언어를 위한 것임

2,000,000,000 이내가 보통 4bite 안에서 해결할 수 있는 수라 보통 10억 이내로 정수 값을 준다.

알고리즘의 출력은 정답이 있지만, 코드에는 정답이 없다.


### 오후
#### 입맛 다시기
알고리즘 첫 시간이다.  
<학습 목표>  
- 논리적 사고력 향상
- 단순히 파이썬을 잘 하기 위함은 아니다. -> 제한된 내장함수만 사용하니 그런 것 같긴 하다.

오늘부터 APS 기본을 배우고 앞으로 APS 응용과 컴퓨팅 사고력 과목을 배운다.  
다른 사람과 비교하며 문제 풀지 말자. 자신의 스피드로 계속해서 나아가라.  
그리고 혹여나 남들보다 잘한다고 거들먹거리지 말자.

#### 알고리즘
문제를 해결하기 위한 절차와 방법  

알고리즘을 표현하는 방식
- 의사코드(슈도코드)와 순서도

> 다른 언어로 작성된 경우가 잦다. 그렇기에 다른 언어로도 순서도를 볼 수 있어야 한다.

<좋은 알고리즘의 기준>
- 정확성: 가장 중요, 정확한 결과
- 작업량: 연산 줄이기
- 메모리 사용량: 인터페이스 기반은 메모리가 확 줄진 않는다.
- 단순성
- 최적성

1부터 100까지의 합을 구하는 문제가 있다고 하자  
알고리즘1: 1부터 100까지 순서대로 더한다.
알고리즘2: 1과 100, 2와 99가 같다는 것에 착안하여 101에 50을 곱한다.

총 연산 수행 횟수에 차이가 존재한다.

<알고리즘의 성능>
시간 복잡도: 실제 걸리는 시간을 측정, 실행하는 명령문의 개수를 확인  
사간 복잡도를 빅-오 표기법을 사용한다.  
시간 복잡도 함수 내에서 가장 큰 영향을 주는 n에 대한 항만 표시, 계수는 제거  
ex) O(3n+2) = O(3n) => O(n)  
O(4) = O(1)

10억번이 대충 1초 정도 걸린다고 상정한다.

### 배열
인덱스를 통해 접근할 수 있는 자료 => 자료구조에서의 배열  
배열의 필요성: 여러 개의 변수가 필요할 때 일일이 다른 변수를 할당하는 것은 비효율적 -> 배열 활용  

1차원 배열은 리트머스지처럼 만들곤 한다.

1차원 배열 선언의 예
- arr = list()
- arr = []
- arr = [1, 2, 3]
- arr = [0] * 10  -> 1차원에서만 사용 가능함

문제 풀이 사이트에서 indexerror를 runtimeerror로 퉁치는 경우가 많다.

.split()의 인자는 공백을 기준으로 리스트 요소를 만드는 거면 굳이 .split(' ')이라고 안 해도 된다.

최대, 최소 값을 구하는 문제는 max(list)로 구하지 말고, for 반복문을 돌리면서 갱신해주는 방식으로 해라.

본인이 가능한 방식으로 문제를 풀도록 하고, 모르는 부분과 아는 부분을 정확히 알고, 모르는 부분을 도움을 구하거라

버블 정렬: 코드가 간결, 개수가 너무 많을 때는 사용하기 어려움, 시간복잡도O(N^2), 버블 정렬은 한 번 순회할 때마다 끝자리부터 한 자리가 결정된다.

```python
# 버블 정렬 인덱스 코드 
N = 5                   # 리스트의 길이가 5라고 할 때
for i in range(N-1, 1):
    # i보다 한 칸 적은 곳까지 비교 why? 오른쪽 놈이랑 비교하니까
    for j in range(i-1):
        list[j] > list[j+1]
```
뒤에서부터 접근하는 것이 인상깊었다. 

``` python
arr[j], arr[j+1] = arr[j+1], arr[j]
```
또 파이썬은 이런 게 가능하다. 배웠는데 이걸 응용 못 해서 바보같이 tmp 사용했던 내가 밉다.

또 음수 방향으로 갈 때는 `for i in range(6, 0, -1)`으로 step을 반드시 적도록 하자.

일반적인 회사의 코딩테스트 난이도는 im - a 사이라고 한다.

```python
import sys
sys.stdin = open('input_view.txt', 'r')            # 표준 입력을 해당 파일의 내용으로 바꿔놓을게
```
stdin -> 콘솔과 연결되어 있는 표준 입력

오늘 알고리즘 과제에서 특정 인덱스의 양옆 -2~2개의 요소를 추가하는 코드를 추가했어야 했는데 if문으로 인덱스를 하나하나 비교해 가면서 무식하게 했는데, 결국 통과는 했다. try-except로 indexerror가 발생했을 때, 더 효율적으로 코드를 짤 수 있을 것 같다고 생각하여 chat gpt에게 코드 요청을 해보았다. 

프롬포트는 다음과 같다.
``` python
python 리스트에서 특정 인덱스의 양옆 -2~2개의 요소를 리스트에 추가하고자 해.
내가 짠 코드는    
for i in range(N):              # 0~99 # n=100
    if i == N-2:
        neighbor = [arr[i-2], arr[i-1], arr[i+1]]
    elif i == N-1:
        neighbor = [arr[i-2], arr[i-1]]
    elif i == 1:
        neighbor = [arr[i+1], arr[i+2], arr[i-1]]
    elif i == 0:
        neighbor = [arr[i+1], arr[i+2]]
    else:
        neighbor = [arr[i - 2], arr[i - 1], arr[i + 1], arr[i + 2]]

이렇게 짰는데 내 생각으로는 try, except 문을 사용해서 IndexError가 발생했을 때, 조작을 통해 더 짧고 간결하게 코드를 짤 수 있을 것 같아.

대안을 제시해줄 수 있을까?
```

```python
# chat gpt가 내게 준 코드

N = 100
arr = [0] * N  # 적절한 리스트로 초기화

result = []

for i in range(N):
    try:
        neighbor = [arr[j] for j in range(i - 2, i + 3) if 0 <= j < N]
        result.append(neighbor)
    except IndexError:
        pass

print(result)
```
사실은 try-except문도 필요없었다. 리스트 표현식을 사용하지 않더라도 이중 for반복문으로 j를 조건으로 사용했더라면 쉽게 짤 수 있었을 것이다. 단순히 2차원 배열을 만드는 것뿐만 아니라 인덱스 에러 방지용으로 for문을 사용할 수 있다는 것

### 알고리듬
앞으로는 함수 단위로 짜는 연습을 해보아야겠다. 그래서 오늘부터 함수 안에 공식을 집어넣고 실행은 바깥에서 함수를 호출해서 진행할 것이다. 이번 문제는 여러 개의 성적을 받고, 다른 성적과의 상대적인 비교를 통한 등급을 산출하여 특정 성적의 등급을 출력하는 문제다. 설명만 들어도 머리가 뜨거워 지는데 실제로 며칠 간 풀지 못 하고 있다.

그래도 곧 풀 것이라고 생각하고, 청사진부터 진행해 봅시다.
우선 최종적으로 원하는 결과는 K를 key로 등급이 value인 딕셔너리를 만드는 것이다. 그런데 인덱스와 점수를 딕셔너리로 만드는 것은 쉽게 구현이 될 듯 한데 점수에 따라 등급으로 치환하고, 딕셔너리의 값으로 넣는 것은 상당한 어려움이 수반될 것이라고 생각한다. 우선 점수까지 구현하는 것은 다음과 같다.

```python
T = int(input())
for t in range(T):
    gpa_list = []
    N, k = int(input().split())
    score_dict = {}
    for n in range(N):
        score = list(map(int(input())))
        gpa = 0.35 * score[0] + 0.45 * score[1] + 0.25 * score[2]
        gpa_list.appned(gpa)


"""
최종 목표
{0:'A'},
{1: B+},
"""
```
함수화를 진행하였다. 또 슬슬 월클병이 돋는 것 같은데 어떻게 될 지 지켜보도록 하자.  
확실히 score을 하나하나 때려넣는 것보다 lambda로 sumproduct와 같은 느낌을 만들어 낼 수 있으니 좋다.  
그리고 이뉴멀레이트도 k같으로 값 찾을 때 용이할 것이라고 생각한다.

```python
def show_grade(N, k):
    list1 = []
    for n in range(N):
        score = list(map(int,input().split()))
        gpa = sum(map(lambda x, y: x*y, score, [0.35, 0.45, 0.2]))
        list_1.append(score)
    # 아직 구현 못함
    list2 = list(enumerate(list1))
    list3 = sorted(list1, reverse=True)
```


### 자습
#### Numpy, Pandas, Matplotlib
어제 해결하지 못한 문제는 그래프를 그렸을 때, x축의 눈금이 말도 안 되게 많이 나온 것을 확인할 수 있었다. 그래서 오늘은 이러한 문제를 해결하기 위해 웹을 뒤져봤는데 좋은 wikidocs가 있어 그것을 참고하여 문제를 풀어보도록 하겠다.  
[Matplotlib Tutorial](https://wikidocs.net/92089)  
x축의 눈금에 관한 사항은 .xticks()라는 pyplot의 메서드를 통해 조정할 수 있다.  

접근을 잘못해도 대단히 잘못했다는 사실을 알았다.  
groupby를 통해 묶는 것이 맞았고 애초에 date의 타입이 날짜가 아닌 object였다. 그것도 모르고 datetime을 통해 묶어버리려고 했다.
```python
import pandas as pd
import matplotlib.pyplot as plt
import datetime as dt

df = pd.read_csv('NFLX.csv', usecols=range(5))
# 이래도 정렬이 되고, date의 데이터 타입을 바꿀 수 있다.
df_after_2021 = df[df['Date'] >= '2021-01-01']
df_after_2021['Date'] = pd.to_datetime(df_after_2021['Date'])
```

이렇게 하고 또 30분 가량 생각하고 아무리 생각해도 몰라서 그냥 실행했는데 원하는 결과가 도출되었다.  
이거 힘이 쫙 빠지는구만

https://wikidocs.net/155456